import webapp2
import json
from google.appengine.ext import ndb
from datetime import datetime
from models import *

def jsonify_entity(entity):
    """Converts an entity to JSON.  Needs work for special cases."""
    entity_dict = entity.to_dict()
    entity_dict['id'] = str(entity.key.id())
    return json.dumps(entity_dict, cls=custom_encoder)

class custom_encoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, datetime):
            return o.isoformat()

        if isinstance(o, ndb.Key):
            return str(o.id())

        return json.JSONEncoder.default(self, o)

######################
# END Bootstrapping, #
# BEGIN Handlers     #
######################

class RestHelper(object):
    def authenticated(self, request_handler):
        """
            Check whether or not the request is authenticated.
            Unimplemented as of now but the current roadmap
            is for BASIC HTTP AUTHENTICATION.
        """
        if request_handler.request.headers.get("password", default="") == "SECRET":
            return True
        return False


    def valid_ids(self, keys):
        """
            A bit of a sloppy solution right now, ensures we don't have any
            exceptions thrown by the NDB API.  Presently we are using the
            Cloud Datastore's autogenerated ids.  The only validation
            we are doing before calling NDB is ensuring our input
            consists of positive (and non-zero) longs.

            Parameters:
                Dict keys:
                    Dict of ids whose values we are validating

            Returns:
                Boolean (Whether or not ids are valid)

            Example:
                keys = dict( a="123", b="234" )
                RestHelper().valid_ids(keys) # Returns True

                keys = dict( a="123", b="xyz" )
                RestHelper().valid_ids(keys) # Returns False
        """
        for key, val in keys.items():
            try:
                temp = long(val)
                if (temp <= 0):
                    return False
            except:
                return False
        return True

    def interpolate_key(self, base_key, args, func=lambda x: x):
        """
            Given a tuple 'base_key', iterate over its elements.  If an element
            of base_key is a key in the dict 'args', substitute it with the
            associated value.  If passed a function, apply that to the
            value before substitution.

            Parameters:
                Tuple base_key:
                    A tuple with values to be replaced
                Dict args:
                    Keys represent string elements of base_key to replace with value
                Function func:
                    A function to call on each value before substituting in base_key

            Returns:
               Tuple (Same size as base_key)

            Example:
                base_key = ("Schedule", "schedule_id")
                args     = dict( schedule_id=123 )
                func     = lambda x: long(x)
                RestHelper().interpolate_key(base_key, args, func)
        """

        output = tuple()
        for x in base_key:
            y = x
            if x in args:
                y = func(args[x])
            output = output + (y,)
        return output

    # Deprecated?
    def list(self, model):
        entities = model.query().fetch()
        output   = RestHelper().to_json(entities)
        return output

    def put(self, model, attributes):
        for key, value in attributes.items():
            setattr(model, key, value)
        model.put()
        return True

    def get(self, request_handler, key_base, args):
        # User must be authenticated
        if (self.authenticated(request_handler) == False):
            request_handler.response.set_status(503)
            return None

        # Valid key's are positive, nonzero longs.
        if (self.valid_ids(args) == False):
            request_handler.response.set_status(400)
            return None

        # We were passed a key tuple where the id values were substituted
        # with
        key    = self.interpolate_key(key_base, args, lambda x: long(x))
        entity = None
        try:
            entity = ndb.Key(*key).get()
        except:
            entity = None

        if (entity == None):
            request_handler.response.set_status(404)
            return None

        request_handler.response.write(jsonify_entity(entity))
        return

    def key_from_id_string(self, model_type, id_string):
        id_long = 0
        try:
            id_long = long(id_string)
            if (id_long <= 0):
                return None
        except:
            return None
        return ndb.Key(model_type, id_long)

    def to_json(self, data):
        if type(data) == list:
            s = []
            for e in data:
                s.append(self.to_json(e))
            return "[" + ",".join(s) + "]"

        # We didn't have a list, so we've got an entity
        data_dict = data.to_dict()
        data_dict['id'] = str(data.key.id())
        return json.dumps(data_dict, cls=custom_encoder)
